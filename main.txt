commit kiểu là một trạng thái một snapshot của 1 file, 1 thư mục, 1 repo tại một thời điểm
branch là một nhánh chứa những commit của nó và trước nó
trong git thì sẽ luôn có một con trỏ nằm ở một commit nào đó
I. Các câu lệnh git
1. Lệnh Git commit:

git commit -m <"Lưu ghi chú cho thay đổi">

lưu thay đổi hoặc lưu phiên bản mới nhất của phiên bản so với phiên bản trước đó của code

gemini: git commit là hành động "chụp ảnh" trạng thái code hiện tại và dán cho nó một cái nhãn để dễ dàng tìm lại sau này.

2. Lệnh Git branch:

git branch <Tên nhánh>
Tạo một nhánh mới trỏ vào commit hiện tại

3. Lệnh Git checkout:

git checkout <Tên nhánh>

Di chuyển con trỏ đến một nhánh 

*Nếu muốn tạo ra một nhánh mới và di chuyển đến nhánh ấy luôn thì có thể dùng lệnh git checkout -b <Tên nhánh>

4. Lệnh Git merge:

git merge <Tên nhánh>

lệnh gộp 2 nhánh này đầu tiên sẽ tạo ra 1 commit mới và chuyển nhánh hiện tại đến commit này. Sau đó cái commit mới này sẽ có cả 2 commit trước đó

Ví dụ: - Có 2 nhánh là bugFix và main, nhánh hiện tại ở main. Lệnh git merge bugFix sẽ tạo ra một commit mới và nhánh main sẽ trỏ vào commit mới này, 
sau đó commit mới này sẽ có 2 commit cha là bugFix và commit trước của main
- Lúc này nếu muốn bugFix cũng nằm ở commit mới cùng main thì chỉ cần di chuyển con trỏ tới nhánh bugFix (git checkout bugFix) rồi sau đó dùng lệnh 
gộp (git merge main), do bugFix là nhánh cha của commit mới mà nhánh main chuyển qua nên bugFix sẽ chỉ đơn giản là di chuyển đến commit mới chứa nhánh main

5. Lệnh Git rebase:

git rebase <Tên nhánh>

Ngược lại với git merge là gộp một nhánh vào nhánh hiện tại thì lệnh git rebase <Tên nhánh> sẽ chuyển toàn bộ commit của nhánh hiện tại vào nhánh 
mình muốn gộp. 
*Nhưng khi dùng rebase thì sẽ không dùng ở nhánh chính mà sẽ dùng ở nhánh phụ. Ví dụ: gộp nhánh chính main và nhánh phụ docs, đầu tiên chuyển đến 
nhánh hiện tại là nhánh phụ docs (git checkout docs) sau đó dùng git rebase main để chuyển toàn bộ commit nhánh docs 
lên trên đầu nhánh main rồi sau đó di chuyển sang nhánh main (git checkout main) rồi dùng git merge docs. Lúc này do các commit thuộc nhánh docs đã nối vào nhánh main 
lên khi dùng merge thì nhánh main sẽ chỉ di chuyển tới vị trí commit của nhánh docs

--Thử nối nhánh

6. lệnh git checkout với Head

6.1 Git checkout HEAD~<number>

Trong git nhánh hiện tại thực chất là một con trỏ HEAD trỏ vào nhánh hiện tại và trỏ vào commit 

Ví dụ: Một repo có thứ tự commit là C0->C1->C2->C3->C4 nhánh hiện tại là nhánh main ở commit thứ 4 thì sẽ là: HEAD->main->C4. Có thể di chuyển giữa các 
commit bằng HEAD như di chuyển đến các nhánh bằng tên nhánh. Như muốn di chuyển đến commit C3 trong khi đang ở C4 thì sẽ dùng git checkout HEAD~1 và di chuyển đến C2 thì 
dùng git checkout HEAD~2 

6.2 Git checkout HEAD^

sử dụng ^ để đi lùi lại các commit trong quá khứ khác với sử dụng ~ ở chỗ chỉ có thể sử dụng ^^ thay vì ^2 khi một nhánh là đường thẳng tức C1->C2->C3->C4 mà không có các commit
là kết quả của lệnh merge 

Ví dụ: Một nhánh đang ở C4 có các commit C1->C2->C3->C4 và muốn lùi về C2 sẽ sử dụng lệnh git checkout HEAD^^ còn nếu một nhánh đã từng dùng lệnh gộp merge như 
C1->C2->C3->}C5             #Tức là C2 nối với cả C3 và C4 rồi sau đó C3 và C4 đều nối với C5 
    C2->C4->}C5    
Khi đó đứng ở C5 các lệnh git checkout HEAD^<number> number ở đây sẽ lùi về các commit cha ngay trước đó và chọn commit theo number mà mình nhập. Số thứ tự các commit sẽ tùy theo 
thời điểm commit

Test Branch Cases
1. Merge (gộp hai nhánh)

Merge được dùng để gộp nội dung và lịch sử của hai nhánh lại với nhau.
Khi merge, Git sẽ tạo ra một merge commit mới, commit này có hai commit cha
và thể hiện trạng thái code sau khi đã kết hợp hai nhánh.

Trong trường hợp không có conflict, Git sẽ tự động gộp code.
Nếu có conflict, người dùng cần chỉnh sửa code để giải quyết conflict
trước khi hoàn tất quá trình merge.

